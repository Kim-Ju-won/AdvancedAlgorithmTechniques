'''
알고리즘 설명 : 이 알곡리즘은 파이썬 리스트 변수를 두개의 포인터를 이용해서 합이 k가 되는 구간이 있는지 체크하는 코드입니다. 두개의 포인터는 i, j는 A[i]+...+A[j]를 의미하며 각각 구간의 시작과 끝을 가르킵니다. 루프를 도는 동안 A[i]+...+A[j]= k가 되는지 체크합니다. 만약 A[i]+...+A[j] <= k라면 끝을 가르키는 포인터인 j를 증가시켜 구간의 길이를 늘려줍니다. 만약 A[i]+...+A[j] > k 이면 시작 포인터인 i를 증가키겨 구간의 길이를 줄여줍니다. 이와 같이 i, j를 변형시켜주어 리스트를 스캔하여 A[i]+...+A[j] = k가 되는 경우를 발견하면 true를 반환하고, 아닌경우 false를 반환합니다.
'''
'''
Big-O시간 : O(n)
설명 : 시작 포인터 i는 for루프는 최악의 경우 n이 될 때까지 진행되어 i는 n번 돌게 됩니다. 이 때 For루프 안에서 끝을 가르키는 포인터 j도 while문을 이용하므로 전체 Big-O시간이 O(n^2)이라고 생각할 수 있지만, j는 for루프 내부에 존재하지만 i의 값에 영향을 받지 않고 진행되어 전체 함수 코드는 O(n+n)으로 O(n)이 걸립니다. 자세히 예를들어 설명하자면, n=5라고 가정할 경우에 i=0, j가 0부터 숫자가 커지며 3까지 진행되었다고 한다면, i=1이 되었을때 j가 0이나 1로 초기되는 것이아니라, 이전에 사용했던 값 3을 유지하게 됩니다. 이 말은, while문은 for문에 종속되어 초기화되면서 진행되는 것이 아니라 별개로 독립적으로 n의 크기인 5번을 진행하게 되는 것입니다. 따라서 while문과 for문을 이용해서 두개의 포인터가 독립적으로 배열의 크기만큼 진행이 되고 각 수행시간은 O(n)과 O(n)이므로 O(n)+O(n)= O(n)이 되어 전체 코드의 수행시간은 O(n)이 됩니다.
'''
# 함수
def sum_k(num, n, k):
	# 연속된 구간합을 저장할 변수, 첫번째 원소를 넣고 초기화
	interval_sum = num[0]
	# 연속된 구간의 끝을 가르키는 포인터 j
	j = 0
	# O(n) : for루프를 도는 동안 k번의 연산을 진행
	for i in range(n):
		# 끝 포인터가 전체 배열 크기를 벗어나지 않고, 구간합이 k이하일때 j를 증가시켜줌
		# while은 i에 종속적으로 포함되지 않아 for문과 독립적으로 O(n)번 진행
		while j+1 < n and interval_sum + num[j+1] <= k :
			j+=1
			interval_sum += num[j]
			# 구간합이 k와 같을경우 반환
			if interval_sum == k :
				return True
		# 합이 큰경우 시작 포인터를 증가시켜줌
		interval_sum -= num[i]
	return False

# 입력
n, k = tuple(map(int, input().split()))
num = list(map(int, input().split()))
# 출력 
print(sum_k(num, n, k))


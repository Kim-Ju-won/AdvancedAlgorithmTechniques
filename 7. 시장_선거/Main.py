'''
알고리즘 설명 : 시장 선거 알고리즘은 Hash-Table을 이용해서 알고리즘을 구현하였습니다. Hash-Table구조로 짜여있는 딕셔너리 자료형을 사용했습니다. 알고리즘은 다음과 같습니다. 먼저 후보와 투표수를 저장할 변수를 딕셔너리로, 그리고 최종적으로 가장득표를 많이 받은 후보와 득표수를 저장할 변수를 선언합니다. 그리고 배열 A를 첫번째 원소부터 순서대로 스캔하며, 딕셔너리에 값을 업데이트 합니다. 딕셔너리에 값이 없을 경우 해당하는 후보의 번호를 key로 그리고 value로 1을 넣어주고, 있을 경우에는 해당 후보번호의 key값을 찾아 value값을 증가시킵니다. 그리고 이 value값은 투표 수가 됩니다. 그리고 최종적으로 가장 많이 득표한 후보와 득표수를 반환하고, 해당 득표수가 과반이상이면 후보의 번호를 아니면 -1을 출력해줍니다.
'''
'''
Big-O 수행시간 : O(n)
이 알고리즘은 '변수 선언 - 득표수를 업데이트 하는 for문 - 과반수 체크 및 출력'으로 이루어져있습니다. 
변수 선언 부분은 딕셔너리와 튜플을 이용하고 따로 for문이 쓰이지 않고 상수시간에 변수를 선언할 수 있습니다.(O(1))
그리고 변수를 순서대로 스캔하는 for문이 있고 해당하는 for문은 배열의 길이 n만큼 돕니다. 또한 내부에 candidate딕셔너리에서 스캔된 A의 원소가 key값으로 존재하는지 체크하는 if문이 있는데, candidate자료형인 딕셔너리는 해시테이블 자료형으로 O(1)이 됩니다. 그리고 candidate가 업데이트 될 때마다 max_candidate의 득표수와 업데이트 value 값을 비교해서 최댓 값도한 함께 업데이트 합니다. 그리고 이는 비교연산만 진행되므로 상수시간만에 해결할 수 있고 해당 for루프는 O(n)*O(1) = O(n)이됩니다. 
그 이후 반환값을 과반수를 체크하는 부분은 비교연산으로 상수시간이 걸려서 전체 코드는 O(1)+O(n) + O(1) = O(n)으로 O(n)이라고 볼 수 있습니다.
'''
# 함수
def elect(n,num):
	# 후보와 투표수를 저장할 변수를 선언합니다.
	# Hash Table 자료형인 파이썬 딕셔너리형태로 선언합니다.
	candidate = dict()
	# max_candiate는 가장 많은 투표의 번호와 투표수를 튜플 형태로 보여줍니다.
	max_candidate = (-1,-1)
	
	# O(n) : for 루프 하나를 사용하였으므로 O(1) * n = O(n)입니다.
	for ele in num:
		# O(1) : 파이썬의 딕셔너리 데이터는 key값을 존재하는지 확인하는 데 평균적으로 O(1)임을 보장합니다.
		# 후보가 딕셔너리에 있는 경우 count수를 늘려줍니다.
		if ele in candidate:
			candidate[ele] += 1
		# 후보가 없는 경우 해당 딕셔너리에 해당 후보를 추가해줍니다.
		else : 
			candidate[ele] = 1
		# 현재 후보가 기존에 가장 많이 투표를 받은 후보보다 많은 득표를 해주었다면 업데이트 합니다.
		if candidate[ele] > max_candidate[1]:
			max_candidate = (ele,candidate[ele])
	# 제일 많이 득표한 후보와 후보의 득표수를 튜플 형태로 반환합니다.
	return max_candidate
# 입력
n = int(input())
num = list(map(int, input().split()))
# 출력
number, count = elect(n,num)

# 과반수 이상 득표를 한 후보의 번호 반환
if count > (n/2):
	print(number)
# 당선자가 없는 경우 -1 반환
else : 
	print(-1)
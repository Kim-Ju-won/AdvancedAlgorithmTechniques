'''
알고리즘 설명 : 이 알고리즘은 Hash-Table(딕셔너리)와 수업시간에 배웠던 투포인터를 이용해서 구현한 알고리즘입니다. 
먼저 p'와 p-p'두 개의 리스트에서 1~k번의 색 번호가 몇 개씩 들어있는지 저장해놓을 수 있는 딕셔너리 변수 두개를 선언합니다. p'딕셔너리는 0개 구간일 때를 가정하므로 전체 딕셔너리 원소를 1~k번을 key로하여 값을 0으로 초기화해두고, 이 때 p-p'는 전체 리스트 구간을 의미하게 되므로 입력받은 리스트의 1~k번까지 구간에서 색이 몇번 씩 나오는지 갯수를 세어 저장해둡니다. 
추가로 각 딕셔너리에 있는 1~k값이 각 1번 이상 씩 나오는지 확인해주는 check변수 두개를 선언해줍니다. 각각 값이 k일 때, 그 구간이 무지개가 되는 조건을 만족합니다. 
두개의 변수 i,j를 각각 p'구간의 시작과 끝점을 가르킬 포인터로 활용합니다. 변수 i는 for문 형태로 n개의 점들을 순회하여 시작점을 가르키게 됩니다. j는 while문을 이용해서 i와 독립적으로 순회합니다. 전체 길이를 넘어선 범위를(n)돌 수 없으며, p'의 딕셔너리 값이 k미만일 때, p-p'딕셔너리 값이 k일때 j는 1씩 증가하면서 순회하게 됩니다. 순회하는 동안 j번째 점의 원소는 p'구간에 속하게 되므로, p'딕셔너리에 j번째 점의 갯수를 1증가 시켜줍니다. 이때 값이 1이 될경우는 처음으로 해당 번호의 원소가 p'구간에 들어왔으므로 p'의 check변수를 1증가 시켜줍니다. 반대로 p-p'의 딕셔너리의 j번째 점의 갯수를 1감소 시켜주고, 해당 값이 0이 될 경우 그 구간에 더이상 해당 번호 색의 점이 존재하지 않는 다는 의미으로 p-p'의 check변수를 1 감소 시켜줍니다. 또 조건이 만족하지 않아 while문 밖으로 나왔을 경우, i번째 점을 같은 방식으로 p구간에서 제외하고 p-p'구간에 포함시켜 각각의 딕셔너리와 check변수를 업데이트 합니다. 이렇게 순회하는 과정속에서 p'의 check==k일때, p-p'의 check==k일때 쌍무지개가 존재하는 경우이므로 j와 i를 이용해서 구간의 길이를 구한 뒤, 이전에 구한 구간의 길이보다 작은 경우 값을 업데이트 해줍니다. 이렇게 투포인터를 이용할 수 잇는 것은 하나의 쌍 무지개 구간이 다른 쌍 무지개 구간을 완전히 포함할 수 없기 때문입니다.
이후 최종적으로 업데이트 된 값을 반환하며 최소 |p'|를 구하게 됩니다.

Big-O시간 : O(n)
이 함수는 rainbow_minimum이라는 하나의 함수를 호출하여 문제를 해결하고 있습니다. 
해당 함수는 투 포인터가 순회하며 배열을 스캔하는 부분과 투 포인터 순회를 위해 사전 작업을 해주는 부분 두 부분으로 나눌 수 있습니다. 
먼저 사전 작업을 하는 부분을 설명해드리면, 해당 부분에서 p', p-p'를 가르키는 딕셔너리 변수 2개, 해당 구간이 무지개임을 확인하는 변수 2개, 최종 |p'|저장할 변수는 상수 시간 만에 선언 됩니다. 그리고 각 딕셔너리를 초기화 시켜줄때, k번 반복하는 루프문(딕셔너리에 키 설정)과 1개, n번 반복하는 루프문 한개(p-p'를 가르키는 딕셔너리 초기화)하는 부분이 있는데, 해당 루프문 안에서는 단순 연산만 일어나므로 각각 O(k), O(n)임을 알 수 있고, 1<=k<=n이므로 O(n)이 사전작업의 최종 Big-O 시간이 됩니다. 
이 후 두개의 포인터를 활용하는 부분인데요. i는 for루프에서 j는 for루프 내부의 while문에서 리스트의 길이인 n만큼 순회하고 있습니다. 그리고 각 for루프 내부에서는 특정한 함수를 호출하지 않으며, 비교연산 산술 연산을 하고 있습니다. 따라서 O(n^2)이라고 생각하실 수 있지만 이 알고리즘은 그렇지 않습니다. 그 이유는 j는 for루프 내부에 존재하지만 i의 값에 영향을 받지 않고 다른 조건하에 움직이기 때문입니다. 따라서 i,j는 for문,while문 이용해서 두개의 포인터가 독립적으로 점들의 길리(리스트 길이)만큼 진행이 되고 각 수행시간은 O(n)과 O(n)이므로 O(n)+O(n)= O(n)이 됩니다. 
따라서 사전작업, 투 포인터를 이용한 순회 모두 O(n)이므로 전체 수행시간도 O(n)이됩니다.
'''
def rainbow_minimum(n, k, points):
	# n의 범위가 10000까지이므로 k가 10000의 반인 5000을 넘을 경우 쌍무지개가 존재할 수 없으므로 0반환
	if k > 5000 : 
		return 0
	# p_dict : 1~k번이 구간 p'에서 나오는 횟수
	# p_diff_dict : 1~k번이 구간 p-p'에서 나오는 횟수
	p_dict = dict()
	p_diff_dict = dict()
	# check_p : p'가 무지개일 경우를 체크하는 변수(만약 이 변수==k이면 p'는 무지개)
	# check_p_diff : p-p'가 무지개일 경우를 체크하는 변수(만약 이 변수==k이면 p'는 무지개)
	check_p = 0
	check_p_diff = 0
	# 무지개일 때 가장 작은 구간을 반환하는 변수
	ans = 10001
	
	# O(k) = O(n) : 0<=k<=n 이므로 딕셔너리를 초기화할 수 있는 값이 최대가 되는 경우는 O(n)이라고 볼 수 있다
	# 반복문은 k번만큼 반복
	# p_diff_dict: 0~k번의 key값 생성
	# check_p_diff : 0~k번의 key값 생성
	for i in range(1,k+1):
		p_dict[i] = 0
		p_diff_dict[i] = 0
	
	# O(n): n개의 점을 확인하여 k에 추가해줄 때, 반복문이 n번 반복이 되므로 O(n)이라고 볼 수 있다.
	# p'구간이 비어있는 구간일 때, p-p'(전체 리스트)에 각 번호가 몇개있는지 딕셔너리에 갯수를 세서 저장
	for p in points : 
		if p in p_diff_dict : # 딕셔너리에 key값이 존재하는지 확인 연산은 O(1)
			p_diff_dict[p] += 1
		else : 
			p_diff_dict[p] = 1
		# check_p_diff는 p-p'가 무지개인지 확인할 수 있도록 하는 변수로 몇개의 색을 가지고 있는지 세준다.
		if p_diff_dict[p] == 1 : 
			check_p_diff += 1
	
	# j-i가 p'의 구간의 길이를 나타내게 된다(i,j는 p'구간을 가르키는 두개의 변수로 활용 i=시작, j= 끝)
	# 투포인터를 이용하기 전 초기화
	# j 포인터는 1부터 시작
	j = 1 
	# i가 처음에 points의 0번째 원소를 가르키면서 시작하므로 해당 시점 초기화
	p_dict[points[0]]=1 # p' 딕셔너리 값 갱신
	check_p += 1 # 색상이 1개 증가했으므로 색상의 갯수를 세줌 
	p_diff_dict[points[0]] -=1 # p' 딕셔너리에 증가되는 동시에 p-p'딕셔너리에서 빠져나감
	if p_diff_dict[points[0]] == 0: # 만약 해당 색상의 원소가 하나도 없을 경우 색상값 감소
		check_p_diff -=1
	
	# O(n)
	for i in range(n): # i포인터를 0~n번 반복
		# j 포인터가 전체 리스트 크기를 벗어나지 않고, 쌍무지개일 경우일 때까지만 움직임
		# while은 i에 종속적으로 포함되지 않아 for문과 독립적으로 O(n)번 진행
		while j+1 < n and check_p < k and check_p_diff == k: 
			# j포인터가 가르키는 원소를 p'값에 추가 및 p-p'값에서 삭제
			# 동시에 그 구간에서 색상의 갯수가 어떤지 세줌
			p_dict[points[j]]+=1
			if p_dict[points[j]]==1:
				check_p+=1
			p_diff_dict[points[j]] -=1
			if p_diff_dict[points[j]] == 0: 
				check_p_diff -=1
			j+=1 # j포인터 갱신
		# 쌍무지개일 경우 더 작은 구간을 저장
		if check_p == k and check_p_diff == k: 
			ans = min(ans, j-i)
		# i 포인터가 이동하였으므로 가르키는 원소를 p-p'값에 추가 및 p'값에서 삭제
		# 동시에 그 구간에서 색상의 갯수가 어떤지 세줌
		p_dict[points[i]]-=1
		if p_dict[points[i]]==0:
			check_p-=1
		p_diff_dict[points[i]] +=1
		if p_diff_dict[points[i]] == 1: 
			check_p_diff +=1
	# ans값이 변화가 없다는 것은 무지개를 찾을 수 없었다는 것이므로 0을 반환
	if ans == 10001 : 
		return 0
	
	return ans
# 입력
n, k = tuple(map(int, input().split()))
points = [int(input()) for _ in range(n)]
# 출력 
print(rainbow_minimum(n, k, points))